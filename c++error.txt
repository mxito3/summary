1，/*心得：调试的时候要耐心，左右移动时要注意，左移从左开始，右移从后边开始，注意保存原始值，写了慢慢调。
尤其注意mid和mid-1,mid+1的那里*/（希尔插入排序调了七八个小时）

2，已经定义好了v[12];
然后又v[12]={0};haha

3,多输入空格导致编译失败

4.虚函数在抽象类定义之后在重定义的时候如果是在派生类外重新定义，那么必须在派生类里面重新声明，
不然的话该派生类就成了抽象类了，该类还需定义，不定义的话该类还是抽象类。

5.抽象类里面除了虚函数，还可以放其他东西

6.a.b是两个对象，a=b;就把b的所有，包括函数定义啊之类的都给了a

7 this指针对象刚建立的时候就有，就是新建立的对象的起始地址，在调用子类的对象的构造函数的时候，先调用基类的构造函数，
此时基类的this指针和子类的this指针的值是一样的

8。为什么构造函数不能是虚函数：

9. stdafx.h : 标准系统包含文件的包含文件，
 或是经常使用但不常更改的
 特定于项目的包含文件

10.#pragma once编译一次

11.引用：
（1）：独立引用：int &ag=a;ag是a的别名，不分配空间
（2）：传参
void swap(int &a,int &b)
{
int t=a;
a=b;
b=t;
}
调用
swap(x,y);
与指针的关系：
（1）：引用不能有空引用
（2）：指针可以有空指针
（3）：指针可以有野指针，引用可以有野引用.
（4）：逻辑上指针与引用没什么区别，传参的时候用引用的话就不会复制。嘿嘿，写起来也简单
（5）：返回值,返回原来的东西的引用。
（6）：* &a指的是a指针的引用

值传递的时候要给形参分配内存，然后进行一次值拷贝。


12.实现虚函数多态的要求：
1.通过指针或者引用调用
2.子类重新定义同名函数



enum是枚举型 union是共用体，

1. 枚举类型定义的一般形式为：

enum 枚举名{ 枚举值表 };


枚举类型在使用中有以下规定：

1.枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。

2. 枚举元素本身由系统定义了一个表示序号的数值，从0开始顺序定义为0，1，2…。如在weekday中，sun值为0，mon值为1，sat值为6。

只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量。。如一定要把数值赋予枚举变量，则必须用强制类型转换。


如：

1

a=(enumweekday)2;



　1.静态方法只能接受静态成员变量

　　2.在静态方法里面并不存在this指针

　　3.不能在类的构造函数里面设置一个静态变量

　　4.必须在类的外部初始化静态变量

　　5.使用静态变量之前必须确保其已经初始化

10.

代码区 //low address

全局数据区

堆区

栈区 //high address


一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。
自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静 态局部变量）也存放在全局数据区。
全局数据区的数据并不会因为函数的退出而释放空间。本文件里面定义的静态变量在其他文件中不能用，但是全局
变量的可以在其他文件里面运用extern int m;的形式调用。

11.一般不要将变量的名字。函数的名字。对象的名字弄成一样的
容易引起冲突。例如排序算法里面。

12，文件包含的时候只需要写头文件，放在符号表里面link的时候链接器自己去找

13.切记：类名要大写

14.
std::pair主要的作用是将两个数据组合成一个数据，两个数据可以是同一类型或者不同类型。例如std::pair<int,float> 或者
 std：：pair<double,double>等。pair实质上是一个结构体，
其主要的两个成员变量是first和second，这两个变量可以直接使用。初始化一个pair可以使用构造函数，
也可以使用std::make_pair函数，make_pair函数的定义如下：
template pair make_pair(t1 a, t2 b) { return pair(a, b); }


15.函子
eg:简单来说是指被当成函数使用的对象，在这里是指GameObjectDeallocator()
	struct GameObjectDeallocator
	{
		void operator()(const std::pair<std::string,VisibleGameObject*> & p) const
		{
			delete p.second;
		
		}
	};


16.图的表示：邻接矩阵
（1）.
例如:
   a    b

a  1    1

b  0    0
(2).

假设一图的邻接矩阵为A,假设N个A矩阵乘积为B,则在图中的长度为N的通路为
B的各个元素的和，V(i)到V(j)的长度为N的通路即为B(i)(j);
（3）。要计算从i 到j有没有通路：
a:把A的1到N次方加起来为Result,看Result(i)(j)是不是零，
b:计算布尔积，从1到N,然后再并起来，假设结果为M,如果M(i)(j)为1，则有通路


17，在操作系统的管理下，所有正在运行的进程轮流使用CPU，每个进程允许占用CPU的时间非常短(比如10毫秒)，
这样用户根本感觉不出来CPU是在轮流为多个进程服务，就好象所有的进程都在不间断地运行一样。但实际上在任何
一个时间内有且仅有一个进程占有CPU。但是如果有多个cpu,进程数小于cpu数，那么就可以实现真正意义上的多进程了，
但如果进程数大于CPU数，则仍然需要使用并发技术。一个进程下面又可以有多个独立运行的小的单位，叫做线程。


18.在一个类里面用了另一个类，即使你包含了他的头文件，也要再把这个类申明一遍。。这是必须的。

 map添加数据；

   map<int ,string> maplive;  
   1.maplive.insert(pair<int,string>(102,"aclive"));
   2.maplive.insert(map<int,string>::value_type(321,"hai"));
可以 maplive[321]=“hai”;

19.迭代器中如果用到eraser.一般不要在for循环中用++；查找某个元素然后删除用eraser(it++);
这里先给it++;然后返回之前的一个副本。不同于前置++和后置++。。。然后删除it。

20.构造函数可以重载，可以定义多个构造函数，在建立对象的时候系统根据参数来确定具体要调用的构造函数，
如果没有定义就会出错。


21.静态变量初始化语句一般放在主函数外面好一点，以免出错

22.一个类里面用到另一个类的成员，要么用公有接口，要么friend,要么继承

23，麻烦的问题用标记

24.eg:
const double pi=3.1415;
const double *const pip=&pi;
第二句从右往左边读，pip是一个const对象，是一个常指针，该指针指向一个double类型的常对象

25.指针的类型必须与所指对象的类型一致，但是有两个例外
（1）
允许指向常量的指针指向一个非常量对象，但是不允许通过该指针改变对象的的值，但是该对象的值可以通过其他方式改变，
（2）
允许一个常量引用绑定一个非常量的对象，字面值，甚至是一个一般表达式
eg:
double dval=3.14;
const int &ri=dval;
为了确保类型相投，编译器产生了一个int类型的临时对象，然后将double转化成int赋给temp，然后将ri与temp绑定，当然
改变ri只是在改变一个临时对象，编译器会报错。

26.编译器不能识别某个东西的时候用类作用域限制符号

